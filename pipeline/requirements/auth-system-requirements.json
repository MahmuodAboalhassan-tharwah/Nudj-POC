{
  "feature": "Authentication & Authorization System",
  "analyzedAt": "2026-02-08T12:00:00Z",
  "summary": "Complete authentication and authorization system for the Nudj platform supporting invitation-based registration, 4-tier hierarchical RBAC (Super Admin > Analyst > Client Admin > Assessor), JWT token management, SSO integration (Azure AD, Google Workspace), MFA, session management, tenant isolation, and Saudi regulatory compliance (PDPL, NCA ECC). This is a foundational feature that ALL other platform features depend on.",
  "prdReferences": {
    "v1": ["REQ-AUTH-001", "REQ-AUTH-002", "REQ-AUTH-003", "REQ-SEC-001", "REQ-ADMIN-003", "REQ-ADMIN-004"],
    "v2": ["REQ-AUTH-001", "REQ-AUTH-002", "REQ-AUTH-003", "REQ-SEC-001", "REQ-SEC-002", "REQ-ADMIN-003", "REQ-ADMIN-004"]
  },
  "requirements": [
    {
      "id": "REQ-AUTH-001",
      "title": "Invitation-Based User Registration",
      "priority": "must-have",
      "description": "Users register via secure invitation links generated by Super Admin (for Client Admins) or Client Admin (for Assessors). Links expire after 7 days. Registration captures name (Arabic/English), email, Saudi mobile number with OTP verification, and role assignment. No self-registration in V1/V2. Duplicate email detection prevents multiple accounts. Registration link pre-assigns user to correct organization and domain(s).",
      "acceptanceCriteria": [
        "Given a Super Admin is logged in, When they create a new client organization and enter an admin email, Then an invitation email is sent within 60 seconds with a registration link valid for 7 days",
        "Given an invitation link has expired, When the invitee clicks it, Then the system displays an expiration message in Arabic/English and provides a 'Request New Invitation' button",
        "Given a Client Admin is logged in, When they invite a Department Assessor, Then the assessor receives an email with a registration link that pre-assigns them to the correct organization and domain(s)",
        "Given a user clicks a valid invitation link, When they fill the registration form, Then the form requires name (Arabic and English fields), email (pre-filled from invitation), Saudi mobile number, and password",
        "Given a Saudi mobile number is entered during registration, When the user submits, Then an OTP is sent via SMS for verification before account creation",
        "Given a user tries to register with an email that already exists, When they submit, Then the system prevents duplicate account creation and shows an appropriate error message",
        "Given registration is complete, When the user is created, Then they are assigned the role specified in the invitation and scoped to the correct organization",
        "Given any registration event occurs, When the account is created, Then an audit trail entry is logged with timestamp, IP address, and invitation reference"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/auth/pages/register.tsx — Registration page with bilingual form (Arabic/English names, email, phone, password)",
          "src/frontend/src/features/auth/pages/invitation-expired.tsx — Expired link page with re-request button",
          "src/frontend/src/features/auth/components/registration-form.tsx — Presentational form component with Zod validation",
          "src/frontend/src/features/auth/components/otp-verification.tsx — OTP input component for Saudi mobile verification",
          "src/frontend/src/features/auth/api/auth.api.ts — TanStack Query hooks: useRegister, useVerifyOTP, useRequestNewInvitation",
          "src/frontend/src/features/auth/types/auth.types.ts — RegisterPayload, InvitationPayload, OTPVerifyPayload types",
          "src/frontend/src/features/auth/hooks/use-invitation-token.ts — Hook to parse and validate invitation token from URL"
        ],
        "backend": [
          "src/backend/app/auth/router.py — POST /auth/register, POST /auth/verify-otp, POST /auth/request-new-invitation, GET /auth/invitation/{token} (validate invitation)",
          "src/backend/app/auth/schemas.py — RegisterRequest, RegisterResponse, OTPVerifyRequest, InvitationValidation schemas",
          "src/backend/app/auth/service.py — register_user(), verify_otp(), create_invitation(), validate_invitation_token(), request_new_invitation()",
          "src/backend/app/auth/models.py — User model, Invitation model (token, email, role, org_id, domain_ids, expires_at, used_at, invited_by)",
          "src/backend/app/auth/invitation_service.py — generate_invitation_token(), send_invitation_email(), check_expiry()"
        ],
        "database": [
          "users table — id (UUID), email (unique), password_hash, name_ar, name_en, phone_sa, role, organization_id, is_active, is_verified, mfa_enabled, mfa_secret, sso_provider, sso_external_id, created_at, updated_at, last_login_at, created_by_invitation_id",
          "invitations table — id (UUID), token (unique), email, role, organization_id, domain_ids (JSONB), expires_at, used_at, invited_by (FK users), created_at",
          "Alembic migration for users and invitations tables"
        ],
        "infrastructure": [
          "Email service integration (SendGrid/AWS SES) for invitation emails",
          "SMS gateway integration for Saudi OTP verification",
          "Redis for OTP storage with TTL (5-minute expiry)"
        ]
      },
      "userJourneys": [
        "Noura Stage 1: INVITATION — Receives email invitation, clicks secure link, creates account",
        "Ahmed Stage 1: ONBOARDING — Receives invitation from Client Admin, creates account via secure link",
        "Fahad Stage 1: CLIENT ONBOARDING — Invites Client Admin after creating organization"
      ],
      "dependencies": [],
      "estimatedComplexity": "high",
      "risks": [
        "SMS OTP delivery reliability in Saudi Arabia — need fallback provider or authenticator app option",
        "Email deliverability — invitation emails may land in spam; need proper SPF/DKIM/DMARC setup",
        "WhatsApp invitation delivery mentioned for V3 consideration — design invitation model to be delivery-channel agnostic",
        "7-day link expiry may be too short for busy HR directors — consider making configurable"
      ]
    },
    {
      "id": "REQ-AUTH-002",
      "title": "Role-Based Access Control (RBAC)",
      "priority": "must-have",
      "description": "Four hierarchical roles with cascading permissions: Super Admin > Analyst > Client Admin > Assessor. Super Admin has full platform access including BDW, benchmark generation, industry reporting, AI Coach admin, and user management. Analyst has assessment review, evidence validation, report generation, AI Coach usage for client advisory. Client Admin has own organization's assessment, team management, results, benchmark reports, AI Coach. Assessor has assigned domains only, evidence upload, own domain results, AI Coach for assigned domains. Tenant isolation enforced: Client Admin/Assessor scoped to their organization only. Analyst scoped to assigned organizations. Role changes are logged in the audit trail.",
      "acceptanceCriteria": [
        "Given a Department Assessor is logged in, When they navigate to a domain they are not assigned to, Then the system returns a 403 and displays 'You do not have access to this section'",
        "Given a Client Admin is logged in, When they attempt to view another organization's data via URL manipulation or API, Then the system returns a 403 and logs the attempt",
        "Given a Super Admin, When they access the Portfolio Dashboard, Then they see aggregated data for all client organizations",
        "Given an Analyst is logged in, When they access an organization they are not assigned to, Then the system returns a 403",
        "Given a Super Admin changes a user's role, When the change is saved, Then an audit trail entry records the previous role, new role, changed_by user, and timestamp",
        "Given any authenticated user makes an API request, When the backend processes it, Then the request is checked against the user's role permissions AND organization scope before any data access",
        "Given a Client Admin, When they access BDW queries or Industry Insights Engine, Then the system returns a 403 (BDW access is Super Admin and Analyst only)",
        "Given an Assessor, When they try to access AI Coach with questions about domains not assigned to them, Then the Coach limits responses to their assigned domains only"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/shared/hooks/use-auth.ts — Hook providing current user, role, permissions, and organization context",
          "src/frontend/src/shared/components/role-guard.tsx — Route guard component checking role before rendering children",
          "src/frontend/src/shared/components/permission-guard.tsx — Fine-grained permission check for UI elements (buttons, tabs, menu items)",
          "src/frontend/src/features/auth/store/auth.store.ts — Zustand store for auth state (user, tokens, permissions)",
          "src/frontend/src/features/auth/types/auth.types.ts — Role enum (SUPER_ADMIN, ANALYST, CLIENT_ADMIN, ASSESSOR), Permission types, RolePermissionMap",
          "src/frontend/src/router.tsx — Route definitions with role-based guards"
        ],
        "backend": [
          "src/backend/app/auth/dependencies.py — get_current_user(), require_role(), require_permission(), require_org_access() FastAPI dependencies",
          "src/backend/app/auth/permissions.py — Role-permission mapping, permission constants, role hierarchy logic",
          "src/backend/app/auth/models.py — Role enum on User model, user_domain_assignments table for assessor-domain mapping",
          "src/backend/app/common/middleware.py — Tenant isolation middleware that injects organization_id filter on all queries"
        ],
        "database": [
          "user_domain_assignments table — id, user_id (FK), assessment_id (FK), domain_ids (JSONB array), assigned_at, assigned_by (FK users)",
          "analyst_org_assignments table — id, user_id (FK users where role=ANALYST), organization_id (FK organizations), assigned_at, assigned_by (FK users)",
          "Role enum type in users table: SUPER_ADMIN, ANALYST, CLIENT_ADMIN, ASSESSOR"
        ],
        "infrastructure": []
      },
      "userJourneys": [
        "All personas — Role determines what they see and can do throughout all stages",
        "Noura Stage 2: SETUP & TEAM INVITE — Client Admin can invite assessors within her org only",
        "Ahmed Stage 2-5: ASSESSMENT through RESULTS — Assessor sees only assigned domains",
        "Salma Stage 1-4: ASSIGNMENT through SCORING — Analyst accesses assigned organizations only",
        "Fahad Stage 1-5: All stages — Super Admin has full cross-organization access"
      ],
      "dependencies": ["REQ-AUTH-001"],
      "estimatedComplexity": "high",
      "risks": [
        "Role hierarchy complexity — ensure cascading permissions are consistent (e.g., Super Admin inherits all lower-role permissions)",
        "Tenant isolation bypass — must be enforced at database query level, not just API middleware, to prevent SQL injection bypasses",
        "Domain-level access for Assessors — need to handle edge cases where domains are reassigned (REQ-COLLAB-002 delegation)",
        "V2 permissions expansion for BDW, AI Coach, benchmark reports — design permission system to be extensible"
      ]
    },
    {
      "id": "REQ-AUTH-003",
      "title": "SSO Integration & Authentication Methods",
      "priority": "should-have",
      "description": "Support Single Sign-On via Azure AD and Google Workspace alongside local email/password authentication. MFA available for all accounts via SMS or authenticator app. Strong password policy enforced for local accounts (min 8 chars, uppercase, number, special character). SSO configuration performed by Super Admin per organization. Session timeout after 30 minutes of inactivity (configurable).",
      "acceptanceCriteria": [
        "Given a client organization has SSO configured via Azure AD, When an invited user clicks the registration link, Then they are prompted to authenticate via their organization's Azure AD provider",
        "Given a client organization has SSO configured via Google Workspace, When a user logs in, Then they are redirected to Google OAuth flow and upon success are authenticated with their platform role",
        "Given SSO is not configured for an organization, When a user registers, Then they create a local account with email and password subject to complexity rules (min 8 chars, uppercase, number, special character)",
        "Given a user enables MFA, When they log in with correct password, Then they must provide a valid OTP from SMS or authenticator app before access is granted",
        "Given a user is authenticated, When they are inactive for 30 minutes, Then their session expires and they are redirected to the login page",
        "Given a Super Admin is configuring SSO for an organization, When they enter Azure AD tenant ID or Google Workspace domain, Then the system validates the configuration and enables SSO login for that organization's users",
        "Given a user with SSO logs in, When SSO authentication succeeds, Then the platform creates or updates their local user record and issues a JWT token pair"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/auth/pages/login.tsx — Login page with email/password form and SSO provider buttons (Azure AD, Google)",
          "src/frontend/src/features/auth/pages/sso-callback.tsx — SSO callback page handling OAuth redirect",
          "src/frontend/src/features/auth/pages/mfa-setup.tsx — MFA setup page (QR code for authenticator, phone for SMS)",
          "src/frontend/src/features/auth/pages/mfa-verify.tsx — MFA verification during login",
          "src/frontend/src/features/auth/components/login-form.tsx — Email/password form with validation",
          "src/frontend/src/features/auth/components/sso-buttons.tsx — SSO provider selection buttons",
          "src/frontend/src/features/auth/components/mfa-input.tsx — 6-digit OTP input component",
          "src/frontend/src/features/auth/components/password-strength.tsx — Password strength indicator matching policy rules",
          "src/frontend/src/features/auth/api/auth.api.ts — useLogin, useSSOLogin, useSSOCallback, useMFASetup, useMFAVerify hooks",
          "src/frontend/src/shared/lib/api-client.ts — Axios/fetch wrapper with JWT interceptor for token refresh"
        ],
        "backend": [
          "src/backend/app/auth/router.py — POST /auth/login, POST /auth/logout, POST /auth/refresh, GET /auth/sso/{provider}, GET /auth/sso/{provider}/callback, POST /auth/mfa/setup, POST /auth/mfa/verify, POST /auth/mfa/disable",
          "src/backend/app/auth/schemas.py — LoginRequest, LoginResponse (access_token, refresh_token, expires_in, user), TokenRefreshRequest, SSOConfig, MFASetupResponse (qr_uri, secret)",
          "src/backend/app/auth/service.py — authenticate_user(), generate_tokens(), refresh_access_token(), revoke_tokens()",
          "src/backend/app/auth/sso_service.py — initiate_sso(), handle_sso_callback(), provision_sso_user(), SSOProviderFactory",
          "src/backend/app/auth/mfa_service.py — setup_mfa(), verify_mfa_token(), disable_mfa()",
          "src/backend/app/auth/jwt_service.py — create_access_token(), create_refresh_token(), verify_token(), decode_token() using python-jose + bcrypt",
          "src/backend/app/auth/password_service.py — hash_password(), verify_password(), validate_password_strength()"
        ],
        "database": [
          "users table additions — mfa_enabled (bool), mfa_secret (encrypted), sso_provider (nullable enum: AZURE_AD, GOOGLE), sso_external_id (nullable), password_hash (nullable if SSO-only)",
          "refresh_tokens table — id (UUID), user_id (FK), token_hash, expires_at, revoked_at, device_info, ip_address, created_at",
          "sso_configurations table — id, organization_id (FK), provider (enum), tenant_id/domain, client_id, client_secret (encrypted), is_active, configured_by (FK users), created_at, updated_at",
          "user_sessions table — id (UUID), user_id (FK), session_token_hash, ip_address, user_agent, last_activity_at, expires_at, created_at"
        ],
        "infrastructure": [
          "Redis for session management (tracking last_activity_at for timeout enforcement)",
          "Redis for refresh token blacklist (revoked tokens)",
          "Environment variables for JWT_SECRET, JWT_ACCESS_TOKEN_EXPIRE_MINUTES, JWT_REFRESH_TOKEN_EXPIRE_DAYS",
          "Azure AD app registration for OAuth",
          "Google Cloud project for OAuth credentials"
        ]
      },
      "userJourneys": [
        "All personas Stage 1 — Authentication is the first touchpoint for all users",
        "Noura Stage 1: INVITATION — Thinking: 'Is this legitimate?' SSO builds trust by using familiar identity provider",
        "Ahmed Stage 1: ONBOARDING — Low-medium technical comfort; SSO reduces friction vs creating new password"
      ],
      "dependencies": ["REQ-AUTH-001"],
      "estimatedComplexity": "high",
      "risks": [
        "Azure AD and Google OAuth require external app registration — need clear setup documentation",
        "SSO user provisioning edge case: user already exists with local account, then org enables SSO — need account linking strategy",
        "JWT secret rotation — need strategy for rotating without invalidating all active sessions",
        "Session timeout may frustrate assessors working on long maturity descriptions — consider 'keep me logged in' option for non-sensitive operations",
        "MFA SMS delivery in Saudi Arabia — same risk as registration OTP, need reliable provider"
      ]
    },
    {
      "id": "REQ-AUTH-004",
      "title": "JWT Token Management",
      "priority": "must-have",
      "description": "JWT-based authentication with short-lived access tokens and longer-lived refresh tokens. Access tokens contain user identity, role, and organization_id for efficient per-request authorization without database lookup. Refresh tokens stored server-side and revocable. Token pair issued on login and SSO callback. Automatic client-side token refresh before expiry.",
      "acceptanceCriteria": [
        "Given a user logs in successfully, When the server responds, Then it returns an access token (short-lived, e.g., 15 minutes) and a refresh token (longer-lived, e.g., 7 days)",
        "Given an access token is about to expire, When the frontend interceptor detects it, Then it automatically calls the refresh endpoint to get a new access token without interrupting the user",
        "Given a refresh token is used, When the server validates it, Then the old refresh token is revoked and a new pair is issued (token rotation)",
        "Given a user logs out, When the logout endpoint is called, Then both the access token and refresh token are revoked/blacklisted",
        "Given a user's account is deactivated by an admin, When the next token refresh attempt occurs, Then the refresh is rejected and the user is forced to re-authenticate",
        "Given a JWT access token, When it is decoded, Then it contains: user_id, email, role, organization_id, and token expiry"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/shared/lib/api-client.ts — HTTP client with request interceptor adding Authorization header, response interceptor handling 401 with automatic token refresh, and queue for failed requests during refresh",
          "src/frontend/src/features/auth/store/auth.store.ts — Token storage (memory for access token, httpOnly cookie for refresh token), isAuthenticated computed, token refresh logic",
          "src/frontend/src/features/auth/hooks/use-session.ts — Hook for session management: auto-refresh, inactivity detection, session expiry handling"
        ],
        "backend": [
          "src/backend/app/auth/jwt_service.py — create_access_token(), create_refresh_token(), verify_token(), decode_token(), revoke_token()",
          "src/backend/app/auth/router.py — POST /auth/refresh endpoint",
          "src/backend/app/auth/dependencies.py — get_current_user() dependency that decodes JWT from Authorization header"
        ],
        "database": [
          "refresh_tokens table (defined in REQ-AUTH-003)"
        ],
        "infrastructure": [
          "Redis for token blacklist with TTL matching token expiry",
          "Environment variables: JWT_SECRET_KEY, JWT_ALGORITHM (RS256 preferred for key rotation), ACCESS_TOKEN_EXPIRE_MINUTES=15, REFRESH_TOKEN_EXPIRE_DAYS=7"
        ]
      },
      "userJourneys": [
        "All personas — Transparent background process; users should never see token management"
      ],
      "dependencies": ["REQ-AUTH-001", "REQ-AUTH-003"],
      "estimatedComplexity": "medium",
      "risks": [
        "Access token in memory is lost on page refresh — need strategy for rehydration (silent refresh via refresh token cookie)",
        "Refresh token rotation must be atomic to prevent race conditions from multiple concurrent requests",
        "RS256 vs HS256 — RS256 enables key rotation but adds complexity; HS256 simpler for POC but harder to rotate"
      ]
    },
    {
      "id": "REQ-AUTH-005",
      "title": "Password Management",
      "priority": "must-have",
      "description": "Password lifecycle management: strong password policy enforcement, secure password hashing (bcrypt), forgot password / reset password flow, and forced password change on first login if set by admin. Password policy: minimum 8 characters, at least one uppercase letter, one number, and one special character.",
      "acceptanceCriteria": [
        "Given a user registers with a local account, When they enter a password, Then the system enforces: minimum 8 characters, at least 1 uppercase, 1 number, 1 special character",
        "Given a user clicks 'Forgot Password' on the login page, When they enter their email, Then a password reset link is sent (valid for 1 hour) and the link includes a secure token",
        "Given a user clicks a valid password reset link, When they enter a new password meeting policy requirements, Then the password is updated, all existing sessions are invalidated, and the user is redirected to login",
        "Given a password reset link has expired, When the user clicks it, Then they see an expiry message and can request a new link",
        "Given a user's password is stored, When the database is examined, Then only the bcrypt hash is stored — never the plaintext password"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/auth/pages/forgot-password.tsx — Forgot password page with email input",
          "src/frontend/src/features/auth/pages/reset-password.tsx — Reset password page with new password form + strength indicator",
          "src/frontend/src/features/auth/components/password-strength.tsx — Reusable password strength indicator (shared with registration)",
          "src/frontend/src/features/auth/api/auth.api.ts — useForgotPassword, useResetPassword hooks"
        ],
        "backend": [
          "src/backend/app/auth/router.py — POST /auth/forgot-password, POST /auth/reset-password",
          "src/backend/app/auth/schemas.py — ForgotPasswordRequest, ResetPasswordRequest",
          "src/backend/app/auth/password_service.py — hash_password() (bcrypt), verify_password(), validate_password_strength(), generate_reset_token()",
          "src/backend/app/auth/service.py — initiate_password_reset(), complete_password_reset(), invalidate_all_sessions()"
        ],
        "database": [
          "password_reset_tokens table — id (UUID), user_id (FK), token_hash, expires_at, used_at, created_at"
        ],
        "infrastructure": [
          "Email service for sending password reset emails (Arabic/English template)"
        ]
      },
      "userJourneys": [
        "All personas — Password management is needed by all users with local accounts",
        "Ahmed Stage 1: ONBOARDING — Low-medium tech comfort, may forget password between sessions (assessments are intermittent)"
      ],
      "dependencies": ["REQ-AUTH-001"],
      "estimatedComplexity": "medium",
      "risks": [
        "Password reset token security — must be cryptographically random, single-use, and time-limited",
        "Brute force attacks on reset endpoint — need rate limiting"
      ]
    },
    {
      "id": "REQ-AUTH-006",
      "title": "Session Management & Security",
      "priority": "must-have",
      "description": "Secure session management with configurable inactivity timeout (default 30 minutes), concurrent session tracking, and security event logging. Session data stored server-side. All login/logout events logged in audit trail with IP address and user agent.",
      "acceptanceCriteria": [
        "Given a user is authenticated, When they are inactive for 30 minutes (configurable per organization), Then their session expires and they are redirected to login with a message",
        "Given a user is active (making requests), When the inactivity timer is checked, Then it resets on each authenticated request",
        "Given a user logs in from a new device, When the session is created, Then the device info (user agent, IP) is recorded",
        "Given a login event occurs (success or failure), When the event is processed, Then an audit trail entry is created with: user email, timestamp, IP address, user agent, success/failure status, and failure reason if applicable",
        "Given Organization A's data is stored, When a user from Organization B attempts to access it via API manipulation, Then the system returns 403 and logs the unauthorized access attempt"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/auth/hooks/use-session.ts — Inactivity timer, auto-logout, session expiry notification",
          "src/frontend/src/features/auth/components/session-expired-modal.tsx — Modal shown when session expires",
          "src/frontend/src/shared/lib/api-client.ts — Attach device fingerprint/user agent to requests"
        ],
        "backend": [
          "src/backend/app/auth/session_service.py — create_session(), extend_session(), expire_session(), get_active_sessions()",
          "src/backend/app/common/middleware.py — SessionActivityMiddleware that updates last_activity_at on each request",
          "src/backend/app/common/middleware.py — TenantIsolationMiddleware that enforces organization_id on all data queries",
          "src/backend/app/auth/router.py — GET /auth/sessions (list active sessions), DELETE /auth/sessions/{id} (revoke specific session)"
        ],
        "database": [
          "user_sessions table (defined in REQ-AUTH-003)",
          "audit_logs table — id (UUID), event_type (enum), user_id (FK nullable), email, ip_address, user_agent, details (JSONB), organization_id (FK nullable), created_at"
        ],
        "infrastructure": [
          "Redis for session activity tracking (last_activity_at with TTL = session_timeout)",
          "Background job (Celery) for cleaning up expired sessions periodically"
        ]
      },
      "userJourneys": [
        "All personas — Session management affects all authenticated interactions",
        "Ahmed Stage 2: ASSESSMENT — 'Session resume' expectation: assessor may step away and return later; session timeout needs to be user-friendly"
      ],
      "dependencies": ["REQ-AUTH-003", "REQ-AUTH-004"],
      "estimatedComplexity": "medium",
      "risks": [
        "30-minute timeout may be too aggressive for assessors filling long Arabic maturity descriptions — PRD v1 AC explicitly states 30 min; consider implementing 'activity' detection including typing/scrolling, not just API calls",
        "Redis as single point of failure for session management — need Redis persistence/replication"
      ]
    },
    {
      "id": "REQ-AUTH-007",
      "title": "User Management (Admin Functions)",
      "priority": "must-have",
      "description": "Super Admin manages Tharwah staff users (Analysts). Client Admin manages their organization's users (Assessors). Both can: invite users, assign/change roles, deactivate users (soft delete, data preserved), and view user activity logs. Bulk invite via CSV upload. Role assignment at invitation time. Activity log per user showing last login, assessment participation. Maps to REQ-ADMIN-003 from PRD.",
      "acceptanceCriteria": [
        "Given a Client Admin invites 5 department assessors, When all accept invitations, Then each appears in the organization's user list with their assigned domains and last activity date",
        "Given a Client Admin deactivates an assessor, When that user attempts login, Then they receive an 'Account deactivated' message and cannot access any data",
        "Given a user is deactivated, When their data is checked, Then all previously created data (assessment responses, evidence, comments) is preserved",
        "Given a Super Admin, When they view user management, Then they can see all users across all organizations with filters by role, organization, and status",
        "Given a Client Admin, When they view user management, Then they see only users within their own organization",
        "Given a Super Admin uploads a CSV of user invitations, When the CSV is valid (columns: email, name_en, name_ar, role, domain_ids), Then bulk invitations are sent and status is shown per row",
        "Given any user management action (role change, deactivation, invitation), When the action completes, Then an audit trail entry is logged"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/admin/pages/user-management.tsx — User list with filters, invite button, bulk actions",
          "src/frontend/src/features/admin/components/user-table.tsx — Sortable/filterable user table component",
          "src/frontend/src/features/admin/components/invite-user-dialog.tsx — Single user invite form",
          "src/frontend/src/features/admin/components/bulk-invite-dialog.tsx — CSV upload for bulk invitations",
          "src/frontend/src/features/admin/components/user-activity-log.tsx — Per-user activity timeline",
          "src/frontend/src/features/admin/api/admin.api.ts — useUsers, useInviteUser, useBulkInvite, useDeactivateUser, useChangeRole hooks",
          "src/frontend/src/features/admin/types/admin.types.ts — UserListItem, InvitePayload, BulkInviteResult types"
        ],
        "backend": [
          "src/backend/app/auth/router.py — GET /users (list, filtered), POST /users/invite, POST /users/bulk-invite, PATCH /users/{id}/role, PATCH /users/{id}/deactivate, PATCH /users/{id}/reactivate, GET /users/{id}/activity",
          "src/backend/app/auth/schemas.py — UserListResponse, InviteUserRequest, BulkInviteRequest, ChangeRoleRequest, UserActivityResponse",
          "src/backend/app/auth/service.py — list_users(), invite_user(), bulk_invite(), change_role(), deactivate_user(), reactivate_user(), get_user_activity()"
        ],
        "database": [
          "users table — is_active field for soft delete",
          "invitations table — supports bulk creation",
          "audit_logs table — captures all user management events"
        ],
        "infrastructure": [
          "CSV parsing library for bulk invite (Python csv module or pandas)",
          "Email service for sending invitations"
        ]
      },
      "userJourneys": [
        "Noura Stage 2: SETUP & TEAM INVITE — Identifies department assessors, sends invitations, assigns domains (REQ-COLLAB-002, REQ-ADMIN-003)",
        "Fahad Stage 1: CLIENT ONBOARDING — Creates organization, invites Client Admin",
        "Fahad Stage 2: PORTFOLIO OVERSIGHT — Assigns analysts to organizations"
      ],
      "dependencies": ["REQ-AUTH-001", "REQ-AUTH-002"],
      "estimatedComplexity": "medium",
      "risks": [
        "CSV bulk invite validation — malformed CSVs, duplicate emails, invalid roles need clear error reporting per row",
        "Reactivation flow — what happens to an assessor's domain assignments after reactivation? Need to re-assign or preserve",
        "Client Admin should NOT be able to change their own role or deactivate themselves"
      ]
    },
    {
      "id": "REQ-AUTH-008",
      "title": "Audit Trail for Authentication Events",
      "priority": "must-have",
      "description": "Comprehensive audit trail covering all authentication and authorization events. Maps to REQ-ADMIN-004 from PRD. Events include: login/logout, failed login attempts, password changes, MFA enable/disable, role changes, user deactivation/reactivation, invitation sent/accepted/expired, session creation/expiry, and unauthorized access attempts. 5-year retention for auth events. Tamper-proof (append-only). CSV export with date range filter.",
      "acceptanceCriteria": [
        "Given a user logs in successfully, When the audit trail is queried, Then an entry exists with: user_id, email, event_type='LOGIN_SUCCESS', timestamp, IP address, and user agent",
        "Given a user fails to log in 5 times, When the audit trail is queried, Then 5 'LOGIN_FAILED' entries exist with the attempted email and IP address",
        "Given a Super Admin views the audit trail, When they filter by event type 'LOGIN_FAILED', Then only failed login entries are shown",
        "Given audit trail data is 5 years old, When the retention policy runs, Then data older than 5 years is archived/deleted per policy",
        "Given a Super Admin exports the audit trail, When they select a date range and click export, Then a CSV file is downloaded containing all matching entries"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/admin/pages/audit-trail.tsx — Audit trail viewer with filters (event type, user, date range, organization)",
          "src/frontend/src/features/admin/components/audit-table.tsx — Paginated audit log table",
          "src/frontend/src/features/admin/api/admin.api.ts — useAuditTrail, useExportAuditTrail hooks"
        ],
        "backend": [
          "src/backend/app/common/audit_service.py — log_event() function called from all auth operations, append-only design",
          "src/backend/app/auth/router.py — GET /audit-trail (filtered, paginated), GET /audit-trail/export (CSV)",
          "src/backend/app/common/schemas.py — AuditLogEntry, AuditLogFilter, AuditLogExportRequest"
        ],
        "database": [
          "audit_logs table — append-only, indexed on (event_type, created_at, user_id, organization_id), partitioned by month for performance"
        ],
        "infrastructure": [
          "Celery task for async audit trail CSV export (large exports)"
        ]
      },
      "userJourneys": [
        "Fahad Stage 3: QUALITY ASSURANCE — Super Admin reviews audit trail for compliance"
      ],
      "dependencies": ["REQ-AUTH-002", "REQ-AUTH-006"],
      "estimatedComplexity": "medium",
      "risks": [
        "Audit log volume can grow very large — need database partitioning strategy (by month/quarter)",
        "Tamper-proof requirement — PostgreSQL with revoked DELETE/UPDATE on audit_logs table for application role",
        "CSV export for large date ranges could be slow — need async export with download notification"
      ]
    },
    {
      "id": "REQ-AUTH-009",
      "title": "Rate Limiting & Brute Force Protection",
      "priority": "must-have",
      "description": "Rate limiting on authentication endpoints to prevent brute force attacks, credential stuffing, and abuse. Account lockout after repeated failed attempts. Rate limits also on AI Coach endpoints (max 50 interactions per user per day per REQ-AI-005). OWASP Top 10 protection for the auth system.",
      "acceptanceCriteria": [
        "Given a user fails to log in 5 times within 15 minutes, When they attempt a 6th login, Then the account is temporarily locked for 30 minutes and a notification is sent to the user's email",
        "Given an IP address sends more than 20 login requests in 1 minute, When the rate limit is exceeded, Then subsequent requests receive HTTP 429 (Too Many Requests)",
        "Given the password reset endpoint, When more than 5 requests for the same email are sent in 1 hour, Then subsequent requests are silently ignored (no error to prevent email enumeration)",
        "Given the registration endpoint, When more than 10 requests from the same IP in 10 minutes are detected, Then subsequent requests receive HTTP 429"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/auth/components/account-locked-message.tsx — Account lockout message with countdown timer"
        ],
        "backend": [
          "src/backend/app/common/middleware.py — RateLimitMiddleware using Redis sliding window",
          "src/backend/app/auth/service.py — check_account_lockout(), increment_failed_attempts(), reset_failed_attempts()",
          "src/backend/app/auth/models.py — failed_login_attempts and locked_until fields on User model"
        ],
        "database": [
          "users table additions — failed_login_attempts (int), locked_until (datetime nullable)"
        ],
        "infrastructure": [
          "Redis for rate limiting counters (sliding window algorithm)",
          "Redis key pattern: rate_limit:{endpoint}:{identifier} with TTL"
        ]
      },
      "userJourneys": [
        "Security — Not directly in user journeys but protects all authentication interactions"
      ],
      "dependencies": ["REQ-AUTH-003"],
      "estimatedComplexity": "medium",
      "risks": [
        "Rate limiting too aggressive may block legitimate users (e.g., organization with many employees behind same IP/NAT)",
        "Account lockout notifications could be used for user enumeration — lockout response must be generic",
        "Redis availability — rate limiting should fail-open (allow requests) if Redis is down, not block all auth"
      ]
    },
    {
      "id": "REQ-AUTH-010",
      "title": "Security Compliance (PDPL & NCA ECC)",
      "priority": "must-have",
      "description": "Authentication system must comply with Saudi Personal Data Protection Law (PDPL) and National Cybersecurity Authority Essential Cybersecurity Controls (NCA ECC). This includes: data encryption at rest (AES-256) and in transit (TLS 1.2+), personal data handling consent, right to data export, right to deletion (with anonymized data preserved for benchmarking), data residency in Saudi Arabia, and security headers.",
      "acceptanceCriteria": [
        "Given user personal data is stored (email, name, phone), When the database is examined, Then sensitive fields are encrypted at rest with AES-256",
        "Given all API communication, When network traffic is inspected, Then all data is transmitted over TLS 1.2+",
        "Given a user requests export of their personal data, When the export is generated, Then it includes all personal information, activity logs, and assessment contributions in JSON/CSV format",
        "Given a client organization requests user data deletion, When the Super Admin processes it, Then PII is removed within 30 days while anonymized assessment scores are preserved for benchmarking",
        "Given the application sends HTTP responses, When security headers are inspected, Then they include: Strict-Transport-Security, X-Content-Type-Options, X-Frame-Options, Content-Security-Policy, X-XSS-Protection"
      ],
      "components": {
        "frontend": [
          "src/frontend/src/features/auth/pages/privacy-settings.tsx — User privacy settings: data export request, account deletion request",
          "Security headers configured in Vite SSR server (server.ts) and/or reverse proxy"
        ],
        "backend": [
          "src/backend/app/auth/router.py — POST /auth/request-data-export, POST /auth/request-deletion",
          "src/backend/app/auth/service.py — export_user_data(), process_deletion_request(), anonymize_user()",
          "src/backend/app/common/middleware.py — SecurityHeadersMiddleware",
          "src/backend/config.py — Encryption keys, CORS settings, security configuration"
        ],
        "database": [
          "Column-level encryption for PII fields (email, name, phone) or transparent database encryption",
          "data_deletion_requests table — id, user_id, requested_at, processed_at, processed_by, status"
        ],
        "infrastructure": [
          "TLS certificate management",
          "Database-level encryption (PostgreSQL TDE or application-level field encryption)",
          "Saudi data center hosting"
        ]
      },
      "userJourneys": [
        "All personas — Privacy and security underpin trust, especially for client organizations uploading sensitive HR evidence",
        "Noura Stage 1: INVITATION — 'Is this legitimate?' Security builds confidence"
      ],
      "dependencies": ["REQ-AUTH-001", "REQ-AUTH-003"],
      "estimatedComplexity": "high",
      "risks": [
        "Application-level encryption adds complexity and performance overhead — evaluate PostgreSQL TDE vs field-level encryption",
        "PDPL compliance details may evolve — design for flexibility in privacy controls",
        "Data deletion must handle cascade: user data, evidence uploads, comments, assessment responses — need clear data ownership model",
        "Right-to-deletion conflicts with audit trail retention (5 years) — PDPL may require resolution"
      ]
    }
  ],
  "dependencyGraph": {
    "REQ-AUTH-001": [],
    "REQ-AUTH-002": ["REQ-AUTH-001"],
    "REQ-AUTH-003": ["REQ-AUTH-001"],
    "REQ-AUTH-004": ["REQ-AUTH-001", "REQ-AUTH-003"],
    "REQ-AUTH-005": ["REQ-AUTH-001"],
    "REQ-AUTH-006": ["REQ-AUTH-003", "REQ-AUTH-004"],
    "REQ-AUTH-007": ["REQ-AUTH-001", "REQ-AUTH-002"],
    "REQ-AUTH-008": ["REQ-AUTH-002", "REQ-AUTH-006"],
    "REQ-AUTH-009": ["REQ-AUTH-003"],
    "REQ-AUTH-010": ["REQ-AUTH-001", "REQ-AUTH-003"]
  },
  "implementationOrder": [
    {
      "phase": 1,
      "label": "Foundation",
      "requirements": ["REQ-AUTH-001", "REQ-AUTH-005"],
      "rationale": "User model, registration, password management are the base for everything else"
    },
    {
      "phase": 2,
      "label": "Core Auth",
      "requirements": ["REQ-AUTH-002", "REQ-AUTH-003", "REQ-AUTH-004"],
      "rationale": "RBAC, login/SSO, and JWT management enable authenticated access"
    },
    {
      "phase": 3,
      "label": "Security Hardening",
      "requirements": ["REQ-AUTH-006", "REQ-AUTH-009", "REQ-AUTH-010"],
      "rationale": "Session management, rate limiting, and compliance controls secure the auth system"
    },
    {
      "phase": 4,
      "label": "Administration",
      "requirements": ["REQ-AUTH-007", "REQ-AUTH-008"],
      "rationale": "User management and audit trail build on all other auth capabilities"
    }
  ],
  "crossCuttingConcerns": [
    {
      "concern": "Tenant Isolation",
      "description": "Every database query MUST filter by organization_id. This is enforced via middleware and service-layer dependencies, not just API-level checks. Critical for PDPL compliance and multi-tenant data safety.",
      "affectedRequirements": ["REQ-AUTH-002", "REQ-AUTH-006", "REQ-AUTH-010"]
    },
    {
      "concern": "Bilingual Support (Arabic/English)",
      "description": "All auth UI pages (login, register, forgot password, MFA) must support Arabic-first with English toggle. All email templates (invitations, password reset, lockout) must be in Arabic by default with English option. Error messages must be bilingual.",
      "affectedRequirements": ["REQ-AUTH-001", "REQ-AUTH-003", "REQ-AUTH-005", "REQ-AUTH-007"]
    },
    {
      "concern": "RTL Layout",
      "description": "All auth forms and pages must render correctly in RTL (Arabic) and LTR (English) layouts. Password strength indicators, OTP inputs, and form validation messages must be RTL-aware.",
      "affectedRequirements": ["REQ-AUTH-001", "REQ-AUTH-003", "REQ-AUTH-005"]
    },
    {
      "concern": "Error Handling",
      "description": "Auth errors must be user-friendly, bilingual, and security-conscious (no information leakage). Failed logins should not reveal whether the email exists. Password reset should always show success message.",
      "affectedRequirements": ["REQ-AUTH-003", "REQ-AUTH-005", "REQ-AUTH-009"]
    }
  ],
  "openQuestions": [
    {
      "id": "OQ-AUTH-001",
      "question": "Should SSO be mandatory or optional per organization? Can users with SSO-enabled orgs still use local email/password?",
      "blocking": "REQ-AUTH-003",
      "suggestedDefault": "SSO optional per org. If SSO enabled, users can choose SSO or local auth. Super Admin can enforce SSO-only per org in future."
    },
    {
      "id": "OQ-AUTH-002",
      "question": "What is the exact inactivity timeout? PRD says 30 minutes but should it be configurable per organization?",
      "blocking": "REQ-AUTH-006",
      "suggestedDefault": "30 minutes default, configurable per organization by Super Admin (min 15 min, max 120 min)"
    },
    {
      "id": "OQ-AUTH-003",
      "question": "Should failed login attempts trigger email notification to the account holder for security awareness?",
      "blocking": "REQ-AUTH-009",
      "suggestedDefault": "Yes, send email after 3+ consecutive failed attempts from unknown IP"
    },
    {
      "id": "OQ-AUTH-004",
      "question": "What SMS provider should be used for Saudi OTP delivery? Twilio, Unifonic (Saudi-based), or MessageBird?",
      "blocking": "REQ-AUTH-001",
      "suggestedDefault": "Unifonic (Saudi-based, better Saudi delivery rates, PDPL-friendly data handling)"
    },
    {
      "id": "OQ-AUTH-005",
      "question": "Should the POC implement full SSO (Azure AD + Google) or defer SSO to post-POC? SSO adds significant complexity.",
      "blocking": "REQ-AUTH-003",
      "suggestedDefault": "POC implements local auth + JWT fully. SSO stubbed with interface but not integrated — implement post-POC."
    },
    {
      "id": "OQ-AUTH-006",
      "question": "JWT algorithm: RS256 (asymmetric, supports key rotation) or HS256 (symmetric, simpler)? RS256 is recommended for production but adds setup complexity.",
      "blocking": "REQ-AUTH-004",
      "suggestedDefault": "HS256 for POC simplicity, with architecture supporting future RS256 migration"
    },
    {
      "id": "OQ-AUTH-007",
      "question": "How should the Tharwah internal staff (Super Admin, Analyst) be initially provisioned? Seeded in database? Separate admin registration flow?",
      "blocking": "REQ-AUTH-001",
      "suggestedDefault": "Initial Super Admin seeded via CLI/migration script. Super Admin then invites other Tharwah staff via the standard invitation flow."
    },
    {
      "id": "OQ-AUTH-008",
      "question": "Should MFA be mandatory for Super Admin and Analyst roles given they have cross-organization access?",
      "blocking": "REQ-AUTH-003",
      "suggestedDefault": "MFA mandatory for Super Admin and Analyst. Optional for Client Admin and Assessor."
    }
  ]
}
